var width = 21
var generations = 20
var current_gen = [0] * width
var next_gen = [0] * width

current_gen at 10 = 1  // Set the initial condition: a single "1" in the middle

fn print_generation(generation) {
    var output = ""
    var i = 0
    while(i < len(generation)) {
        if (generation[i] == 1) {
            output += "1"
        } else {
            output += "0"
        }
        i += 1
    }
    print(output)
}

fn rule110(left, center, right) {
    // Rule 110 logic: 1 if (left XOR (center OR right))
    return left ^ (center | right)
}

fn generate_next(current_gen) {
    var i = 1
    while(i < width - 1) {
        var left = current_gen[i - 1]
        var center = current_gen[i]
        var right = current_gen[i + 1]

        next_gen at i = rule110(left, center, right)  // Using "at" for assignment
        i += 1
    }
    next_gen at 0 = current_gen[0]  // First cell stays the same
    next_gen at (width - 1) = current_gen[width - 1]  // Last cell stays the same
}

fn main() {
    print("Initial generation:")
    print_generation(current_gen)

    var generation = 0
    while(generation < generations) {
        print("\nGeneration " + str(generation + 1) + ":")
        generate_next(current_gen)
        print_generation(next_gen)

        // Move to the next generation
        current_gen = next_gen
        next_gen = [0] * width  // Reset next_gen
        generation += 1
}

main()
